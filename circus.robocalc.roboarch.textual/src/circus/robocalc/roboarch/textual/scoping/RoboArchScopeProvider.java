/********************************************************************************
 * Copyright (c) 2022 University of York and others
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * SPDX-License-Identifier: EPL-2.0
 *
 * Contributors:
 *   William Barnett - initial definition
 ********************************************************************************/

/*
 * generated by Xtext 2.23.0
 */
package circus.robocalc.roboarch.textual.scoping;

import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.xtext.EcoreUtil2;
import org.eclipse.xtext.scoping.IScope;
import org.eclipse.xtext.scoping.Scopes;
import org.eclipse.xtext.scoping.impl.SimpleScope;
import org.eclipse.xtext.util.SimpleAttributeResolver;

import com.google.inject.Inject;

import org.eclipse.xtext.resource.EObjectDescription;
import org.eclipse.xtext.resource.IEObjectDescription;
import org.eclipse.xtext.naming.IQualifiedNameProvider;
import org.eclipse.xtext.naming.QualifiedName;

import circus.robocalc.roboarch.System;
import circus.robocalc.robochart.Connection;
import circus.robocalc.robochart.Event;
import circus.robocalc.robochart.Expression;
import circus.robocalc.robochart.Interface;
import circus.robocalc.robochart.NamedExpression;
import circus.robocalc.robochart.RoboChartPackage;
import circus.robocalc.robochart.RoboticPlatformDef;
import circus.robocalc.robochart.TypeDecl;
import circus.robocalc.robochart.TypeRef;
import circus.robocalc.robochart.Variable;
import circus.robocalc.roboarch.CSkill;
import circus.robocalc.roboarch.DSkill;
import circus.robocalc.roboarch.Layer;
import circus.robocalc.roboarch.Monitor;
import circus.robocalc.roboarch.ReactiveSkills;
import circus.robocalc.roboarch.RoboArchPackage;
import circus.robocalc.roboarch.Skill;
import circus.robocalc.roboarch.SkillConnection;
import circus.robocalc.roboarch.PlatformCommunicator;

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
public class RoboArchScopeProvider extends AbstractRoboArchScopeProvider {
	@Inject IQualifiedNameProvider qnp;
	
	
	@Override
	public IScope getScope(EObject context, EReference reference) {
		
		//IScope globalScope = super.getScope(context, reference);

		/*RoboChart Types
		
			Use global scope for --- reference == RoboChartPackage.Literals.TYPE_REF__REF
		*/

	   if (  RoboChartPackage.Literals.EXPRESSION.isSuperTypeOf( reference.getEContainingClass() )  ) {
			IScope expscope = scopeForNamedExpression(context);
			return expscope;
		
	    //Skill Connection Variable From
		} else if  ( reference == RoboArchPackage.Literals.SKILL_CONNECTION__END_INPUT && context instanceof SkillConnection ) {
			
			SkillConnection skillcon = (SkillConnection) context;
			return scopeForConnectionVariable( skillcon.getEnd() );
		
		//Skill Connection Variable To
		} else if  ( reference == RoboArchPackage.Literals.SKILL_CONNECTION__START_OUTPUT  && context instanceof SkillConnection
	                 //|| reference == RoboArchPackage.Literals.MONITOR__INPUTS TODO
	                 ){
			SkillConnection skillcon = (SkillConnection) context;
			return scopeForConnectionVariable( skillcon.getStart() );
		
        // Connection Event From
		} else if ( reference == RoboChartPackage.Literals.CONNECTION__EFROM &&  (context instanceof Connection) ) {
			
			Connection con = (Connection) context;
			return scopeForConnectionEvent( con.getFrom() );
			
		// Connection Event To
		} else if ( reference == RoboChartPackage.Literals.CONNECTION__ETO &&  (context instanceof Connection)) {
			Connection con = (Connection) context;
		    return scopeForConnectionEvent( con.getTo() );
	}
		
		//Use the default scope provider for anything else.
		return super.getScope(context, reference);
	}
	
	private IScope scopeForRoboChartTypes( EObject context ) {
		//All types in the RoboArch model
		EObject rootElement = EcoreUtil2.getRootContainer(context);
	    List<EObject> candidates = new ArrayList<EObject>();
	    
	    candidates.addAll( EcoreUtil2.getAllContentsOfType(rootElement, TypeDecl.class) ) ;
	    
	    return Scopes.scopeFor(candidates);
	}
	
	private IScope scopeForVariable( EObject context ) {
		//All Variables in the RoboArch model
		EObject rootElement = EcoreUtil2.getRootContainer(context);
	    List<EObject> candidates = new ArrayList<EObject>();
	    		
	    candidates.addAll( EcoreUtil2.getAllContentsOfType(rootElement, Variable.class) );
	    
	    return Scopes.scopeFor(candidates);
	}

	private IScope scopeForEvent( EObject context ) {
		//All Events in the RoboArch model
		EObject rootElement = EcoreUtil2.getRootContainer(context);
	    List<EObject> candidates = new ArrayList<EObject>();
	    		
	    candidates.addAll( EcoreUtil2.getAllContentsOfType(rootElement, Event.class) );
	    
	    return Scopes.scopeFor(candidates);
	}
	
	
	private IScope scopeForConnectionEvent( EObject context ) {
		//All Events in the RoboArch model
	    List<EObject> candidates = new ArrayList<EObject>();
	       
	    candidates.addAll( context.eContents() );
	    candidates.removeIf(e -> !(e instanceof Event));
	    
	    if ( context instanceof RoboticPlatformDef ) {
	    	RoboticPlatformDef platform = (RoboticPlatformDef) context;
	    	
	    	for ( Interface i: platform.getInterfaces() ){
	    		candidates.addAll( i.getEvents() );
	    	}
	    }
	    
	    if ( context instanceof PlatformCommunicator ) {
	    	PlatformCommunicator communicator = (PlatformCommunicator) context;
	    	
	    	for ( Interface i: communicator.getInterfaces() ){
	    		candidates.addAll( i.getEvents() );
	    	}
	    }

	    return Scopes.scopeFor(candidates);
	}
	
	// TODO make more generic with scopeForConnectionEvent
	private IScope scopeForConnectionVariable( EObject context ) {
		//All Events in the RoboArch model
	    List<EObject> candidates = new ArrayList<EObject>();
	       
	    candidates.addAll( context.eContents() );
	    candidates.removeIf(e -> !(e instanceof Variable));

	    return Scopes.scopeFor(candidates);
	}
	
	private IScope scopeForNamedExpression( EObject context ) {
		
		EObject container = context.eContainer();
		
		IScope scope;
		
		if (container instanceof System) {
			System sys = (System) container;
			Collection<EObject> result = new ArrayList<EObject>();
			
			result.addAll( sys.getDefinitions() );
			result.addAll( sys.getFunctions() );
			
			scope= Scopes.scopeFor( result );
			
		} else if (container instanceof ReactiveSkills) {
			List<IEObjectDescription> results = new ArrayList<IEObjectDescription>();
			
			List<Skill> skills =  ((ReactiveSkills) container).getSkills(); 
			
			for (Skill skl:skills)  {
				for (Variable pm: skl.getParameters() ) {
					results.add( EObjectDescription.create(
									QualifiedName.create( skl.getName(), pm.getName() ),
									pm ) 
								);
				};				
				
						
				if (skl instanceof DSkill) {
					for (Variable sd:((DSkill) skl).getOutputs() ) {
						results.add( EObjectDescription.create(
										QualifiedName.create( skl.getName(), sd.getName() ),
										sd) );
					};
				}
				
				if (skl instanceof CSkill) {
					for (Variable op : ((CSkill) skl).getOutputs() ) {
						results.add( EObjectDescription.create(
										QualifiedName.create( skl.getName(), op.getName() ), 
										op) );
					}
				}
				
			}
			scope=  new SimpleScope ( scopeForNamedExpression(container), results );
			//return new SimpleScope (results);
			
			
		} else {
			scope= scopeForNamedExpression(container);
		}
		
		return scope;
	}
	
	private System containingSystem( EObject context ) {
		
		EObject container = context.eContainer();
		
		if (context instanceof System) {
			
			return (System) context;
			
		} else if (container instanceof System) {
			
			return (System) container;
					
		} else {
			return containingSystem(container);
		}		
	}
	
	
	/*
	private IScope scopeForMonitorExpression( EObject context ) {
		//All Variables in the RoboArch model
		EObject rootElement = EcoreUtil2.getRootContainer(context);
	    List<EObject> candidates = new ArrayList<EObject>();
	    
	    candidates.addAll( EcoreUtil2.getAllContentsOfType(rootElement, Skill.class) );
	    candidates.addAll( EcoreUtil2.getAllContentsOfType(rootElement, NamedExpression.class) );
	    
	    return Scopes.scopeFor(candidates);
	} */
	
	/*private IScope expressionsDeclared(Monitor cont, IScope parent) {
		Scopes.scopeFor(
			cont.operations.stream().filter(o -> instanceof Monitor).collect(Collectors.toList(),
			Scopes.scopeFor(
				cont.RInterfaces.operationsInInterfaces,
				Scopes.scopeFor(cont.PInterfaces.operationsInInterfaces, parent)
			)
		)
	}*/
	
}


