/********************************************************************************
 * Copyright (c) 2022 University of York and others
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * SPDX-License-Identifier: EPL-2.0
 *
 * Contributors:
 *   William Barnett - initial definition
 ********************************************************************************/

/*
 * generated by Xtext 2.23.0
 */
package circus.robocalc.roboarch.textual.validation;

import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.Stack;
import java.util.function.Supplier;
import java.util.stream.Collectors;

import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EStructuralFeature;
import org.eclipse.emf.ecore.util.EcoreUtil;

import org.eclipse.xtext.validation.Check;

import circus.robocalc.roboarch.CSkill;
import circus.robocalc.roboarch.ControlLayer;
import circus.robocalc.roboarch.ExecutiveLayer;
import circus.robocalc.roboarch.Htn;
import circus.robocalc.roboarch.Layer;
import circus.robocalc.roboarch.Pattern;
import circus.robocalc.roboarch.PlannerScheduler;
import circus.robocalc.roboarch.PlanningLayer;
import circus.robocalc.roboarch.PlatformCommunicator;
import circus.robocalc.roboarch.ReactiveSkills;
import circus.robocalc.roboarch.RoboArchPackage;
import circus.robocalc.roboarch.Subsumption;
import circus.robocalc.roboarch.System;
import circus.robocalc.roboarch.util.Model;
import circus.robocalc.robochart.Connection;
import circus.robocalc.robochart.ConnectionNode;
import circus.robocalc.robochart.RoboChartPackage;
import circus.robocalc.robochart.RoboticPlatform;


/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
public class RoboArchValidator extends AbstractRoboArchValidator {
	
	protected static String ISSUE_CODE_PREFIX = "circus.robocalc.roboarch.";
	
	
	
	/* 
	 * Top Level
	 */
	
	//old
	public static String LAYERS_NOT_DISTINCT_TYPES =
			ISSUE_CODE_PREFIX + "LayerTypesNotDistinct";
	

	///////////////////////////////////////////////////////
	

	// S1
	public static String ROBOTIC_PLATFORM_UNUSED =
			ISSUE_CODE_PREFIX + "RoboticPlatformUnused";	
	
	// S2
	public static String LAYER_WITHOUT_IO =
			ISSUE_CODE_PREFIX + "LayerWithoutIO";		
	
	// S3
	public static String LAYER_ORDER_INVALID =
			ISSUE_CODE_PREFIX + "LayerOrderInvalid";
	
	// S4 - Inherited from RoboArch validator.
	//public static String CONNECTION_EVENT_TYPES =
	//		ISSUE_CODE_PREFIX + "ConnectionEventTypes";		
	
	// S5
	public static String CONNECTION_DIRECTION =
			ISSUE_CODE_PREFIX + "ConnectionDirection";		
		
	
	// S6
	public static String CONNECTION_ASSOCIATIONS_LAYERS =
			ISSUE_CODE_PREFIX + "ConnectionsAssociationsLayers";		
	
	// S7
	public static String CONNECTION_ASSOCIATIONS_CONTROLLAYER =
			ISSUE_CODE_PREFIX + "ConnectionsAssociationsControlLayer";	
	
	//TODO implement
	public static String CONNECTIONS_PLATFORM_ASSOCIATION =
			ISSUE_CODE_PREFIX + "ConnectionsPlatformAssociation";	

	//	TODO Update according to latest well-formedness
	 

	// S1
	@Check
	public void roboticPlatformIsUsed(System sys) {
		
		// Check connections for one that exists between a layer and the platform 
		boolean layerConnectionExists; 
		
		Stack<Connection>  systemConnections = new Stack<Connection>();
		systemConnections.addAll( sys.getConnections() );
		
		layerConnectionExists = false;
		
		while (!layerConnectionExists && !systemConnections.empty() ) {
			Connection con = systemConnections.pop();
			
			if( con.getFrom() instanceof RoboticPlatform ) {
				layerConnectionExists = con.getTo() instanceof Layer;
				
			} else if ( con.getTo() instanceof RoboticPlatform ){
				layerConnectionExists = con.getFrom() instanceof Layer;
				
			} else {
				layerConnectionExists = false; // Not a connection involving the RoboticPlatform
			}
				
		}
		
		
	    // Check for a layer with an rInterface
		Stack<PlatformCommunicator> platformCommunicableLayers = new Stack<PlatformCommunicator>();
		
		platformCommunicableLayers.addAll( EcoreUtil.getObjectsByType(sys.getLayers(), RoboArchPackage.Literals.PLATFORM_COMMUNICATOR) ); 
		boolean layerWithRinterfaceExists;
		
		if ( platformCommunicableLayers.empty() ) {
			
			layerWithRinterfaceExists = false;
		}
		else {
			layerWithRinterfaceExists = false;

			while(!layerWithRinterfaceExists && !platformCommunicableLayers.empty() ) {
				PlatformCommunicator layer = platformCommunicableLayers.pop();
				
				layerWithRinterfaceExists = (layer.getRinterfaces().size() > 0); 
			}
		
		}
		
		if ( !layerConnectionExists && !layerWithRinterfaceExists) {
			error("The robotic platform must be used.", RoboArchPackage.Literals.SYSTEM__ROBOT , ROBOTIC_PLATFORM_UNUSED);
		}
		
	   
	}
	

	
	
	// S2
	@Check
	public void layerWithoutInputOrOutput(Layer lyr) { 
		
		EObject lyrParent = lyr.eContainer();
		
	    if (lyrParent instanceof System) {
	    	System sys = (System) lyrParent ;
	    	
			if ( sys.getLayers().size() > 1 ) {
				
					if( lyr.getInputs().isEmpty() && lyr.getOutputs().isEmpty() ) {
						error("Layer '" + lyr.getName() + "' has no inputs or outputs.", RoboArchPackage.Literals.LAYER__INPUTS , LAYER_WITHOUT_IO);
					}
				
			}
	    }
		
	}
	

	// S3
	@Check
	public void layerOrder(System sys) { 
		
		List<Layer> conLyrs = sys.getLayers().stream().filter( l -> l instanceof ControlLayer ).collect(Collectors.toList());
		 
		List<Layer>  exeLyrs = sys.getLayers().stream().filter( l -> l instanceof ExecutiveLayer ).collect(Collectors.toList());
		
		List<Layer> plnLyrs = sys.getLayers().stream().filter( l -> l instanceof PlanningLayer ).collect(Collectors.toList());
		
		
		/* If there are three of the distinct layer types then validate the ordering by checking that the control and planning layers
	       are not associated via connections ignoring generic layers.  */
		if( !conLyrs.isEmpty() && !exeLyrs.isEmpty() && !plnLyrs.isEmpty() ) {
			
			Layer  controlLayer  = conLyrs.get(0); // There can only be one control layer	
			
			// Find all the connections directly involving the control layer
			Stack<Connection> conConnections = new Stack<Connection>();
			
			conConnections.addAll( sys.getConnections().stream().filter( c -> ( c.getFrom() instanceof ControlLayer ) || 
					                                                          ( c.getTo() instanceof ControlLayer) 
					                                                     ).collect(Collectors.toList()) ) ; 
			
			
			// If there is a connection between the control and planning layers the ordering is incorrect as there are 3 possible types
			boolean controlPlanningAreConnected = false;
			
			while( !conConnections.isEmpty() && !controlPlanningAreConnected) {
				
				Connection currentConnection = conConnections.pop();
				
				List<Class> connectedLayers = findDestinationLayerTypeFromSystemsConnections( currentConnection, ControlLayer.class, sys.getConnections() );
				
				controlPlanningAreConnected = connectedLayers.stream().anyMatch( lc -> PlanningLayer.class.isAssignableFrom(lc) );
			}
			
			if (controlPlanningAreConnected) {
				error("The ordering of layer types ignoring generic types must be Control < Executive < Planning.", RoboArchPackage.Literals.SYSTEM__CONNECTIONS , LAYER_ORDER_INVALID);
			}
			
		}
	}	
	
	
	/* Follows the connections via generic layers until an associated Control, Executive, and Planning layer is found  */
	private <T extends Layer> List<Class> findDestinationLayerTypeFromSystemsConnections( Connection start , Class<T> startType, List<Connection> systemConnections) {
		
		boolean newAssociationsToCheck;
		
		List<Connection> currentBaseConnections = new ArrayList<Connection>();
		currentBaseConnections.add(start);
		
		List<Connection> checkedConnections = new ArrayList<Connection>();
		
		
		List<Class> destinationTypes = new ArrayList<Class>();
		
		
		if ( !startType.isInstance(start.getFrom()) &&  !startType.isInstance(start.getTo()) ) {
			
			throw new IllegalArgumentException("The startType does not match either the start connection from or to.");
		}
		
				
		boolean searchDirectionFromTo = startType.isInstance(start.getFrom()); // Determines the direction that is searched
		
		
		ConnectionNode currentConnectionNode; 
		
		if (searchDirectionFromTo) {	
			currentConnectionNode = start.getTo();
		} else {
			currentConnectionNode = start.getFrom();
		}
		
		
		// Don't have to search if the connection is directly between two layer types of Control, Executive, and planning.
		if ( searchDirectionFromTo && isControlExecutivePlanningType(start.getTo()) ) {
		
			destinationTypes.add( start.getTo().getClass() );
			return destinationTypes;
					
		} else if ( !searchDirectionFromTo && isControlExecutivePlanningType(start.getFrom()) ) {
			
			destinationTypes.add(start.getFrom().getClass() );
			return destinationTypes;
		}
		
		
		//Start layer is the source
		do {
			
			
			// Find all connections that are associated with the base connections
			List<Connection> foundConnections= new ArrayList<Connection>();
			
			for(Connection baseConnection: currentBaseConnections){					
				foundConnections.addAll( findAssociatedConnections( currentConnectionNode, baseConnection,  systemConnections) );
			}
				
			newAssociationsToCheck =  !checkedConnections.containsAll( foundConnections );
			
			
			if (newAssociationsToCheck) {
				// update current type and base connection for next search
				if (searchDirectionFromTo) {
					currentConnectionNode= foundConnections.get(0).getTo();
				} else {
					currentConnectionNode= foundConnections.get(0).getFrom();
				}
				
				currentBaseConnections.clear(); 
				
				// Check to see if the destinations of the found connections to see if they are Control, Executive, or Planning layer types
				for(Connection c: foundConnections) {
					
					if ( searchDirectionFromTo && isControlExecutivePlanningType(c.getTo())  ) {
						destinationTypes.add(c.getTo().getClass());
						
					} else if (!searchDirectionFromTo && isControlExecutivePlanningType(c.getFrom())) {
						destinationTypes.add(c.getFrom().getClass());	
						
					} else {
						// Haven't reached a layer type so add it to the list search next
						currentBaseConnections.add(c);
					}
					
					checkedConnections.add(c);
				}
			
				foundConnections.clear(); // Prepare for next search
			}
		
		} while ( newAssociationsToCheck );

		return destinationTypes;
	}
	
	
	
	private boolean isControlExecutivePlanningType( ConnectionNode lyr ) {
		return ( lyr instanceof ControlLayer || lyr instanceof ExecutiveLayer || lyr instanceof PlanningLayer  );
	}
	
	/* 
	 *  From a set of connections finds all instances of connection related by a common layer for a given  connection and start node.  
	 */
	private List<Connection> findAssociatedConnections( ConnectionNode startNode, Connection base, List<Connection> cons ){
		
		List<Connection> connectionsToSearch = cons.stream().filter( c ->   !c.equals(base) ).collect(Collectors.toList()) ;
		List<Connection> associatedConnections = new ArrayList<Connection>();
		
		if ( startNode.equals( base.getTo() ) ) {
			
			// The base matches the start node so find connection node associations that match the to type
			associatedConnections.addAll( connectionsToSearch.stream().filter( c -> (  c.getTo().equals(base.getTo())   || 
					                                                                   c.getFrom().equals(base.getTo())   
					                                                  )     
					                                            ).collect( Collectors.toList()) );                                              
			
			
		} else if ( startNode.equals(base.getFrom()) ) {
			
			// The base matches the start node so find connection node associations that match the from type
			associatedConnections.addAll( connectionsToSearch.stream().filter( c -> ( c.getFrom().equals(base.getFrom()) ||
																                      c.getTo().equals(base.getFrom())
																      )					
																).collect(Collectors.toList()) );
			
		} else {
			// No associated connections
		}
		
		return associatedConnections;
	}
	
		
	
	// S4 

	//    Inherited from RoboArch connections - Connection efrom and eto types must match.
	
	
	// S5
	
	@Check
	public void connectionFromIsAnOutput(Connection con ) {
		
		
		if ( con.getFrom() instanceof Layer ) {
			
			Layer lyr = (Layer)  con.getFrom(); 
			
			//Check for inputs that are invalid 
			if ( Model.isEventLayerInput( lyr, con.getEfrom() ) )  {
			
				error("The source of a connection must be an output.", RoboChartPackage.Literals.CONNECTION__EFROM , CONNECTION_DIRECTION);
			}
			

		}
		
	} 
	
	@Check
	public void connectionToIsAnInput(Connection con ) {

		if ( con.getTo() instanceof Layer ) {
			
			Layer lyr = (Layer)  con.getTo(); 
			
			//Check for outputs that are invalid 
			if ( Model.isEventLayerOutput( lyr, con.getEto() ) )  {
				
				error("The destination of a connection must be an input.", RoboChartPackage.Literals.CONNECTION__ETO , CONNECTION_DIRECTION);
			}
			
		}
		
	} 
	
	
	
	// S6 and S7
	
	@Check
	public void connectionsLayerTotalAssociations(Layer lyr ) {
		
		System sys = (System) lyr.eContainer();
		
		Set<ConnectionNode> connectedLyrs = new HashSet<ConnectionNode>();
		
		
		// Find associated connections from then to 
		
		List<Connection> associatedConnectionsFrom =  sys.getConnections().stream().filter( c -> (  c.getFrom().equals(lyr) ) 
				                                                                            ).collect( Collectors.toList() )  ;   
		for(Connection c: associatedConnectionsFrom) {
			connectedLyrs.add( c.getTo() );
		}
		
		
		List<Connection> associatedConnectionsTo =  sys.getConnections().stream().filter( c -> (  c.getTo().equals(lyr) ) 
																							).collect( Collectors.toList() )  ; 
		for(Connection c: associatedConnectionsTo) {
			connectedLyrs.add( c.getFrom() );
		}		
		
		// Remove any type that are not layers
		associatedConnectionsFrom.removeIf( node -> !( node instanceof Layer) ) ;
		
		
		// Check the maximum number of layers
		if ( (lyr instanceof ControlLayer) && connectedLyrs.size() > 1) { // S7	
			error("Layer '"+ lyr.getName() +"' is associated with '" + connectedLyrs.size() + "' layers. A Control layer must only be associated with at most one other layer.", 
					RoboChartPackage.Literals.NAMED_ELEMENT__NAME , CONNECTION_ASSOCIATIONS_CONTROLLAYER);
		
		} else if ( connectedLyrs.size() > 2 ) { // S6
			error("Layer '"+ lyr.getName() +"' is associated with '" + connectedLyrs.size() + "' layers. A layer must only be associated with at most two other layers.", 
					RoboChartPackage.Literals.NAMED_ELEMENT__NAME , CONNECTION_ASSOCIATIONS_LAYERS);
		}
		
	}
	
	
	
	
	////////////////////////////////////////////////////////////////////////////
	
	@Check
	public void layersAreDistinctTypes(System sys) {
		Set< Class<Layer> > layerTypes = new HashSet();
		List<Layer> systemLayers = sys.getLayers(); 
		Layer duplicateLayerType=null;
		
		for (Layer l: systemLayers) {
			boolean duplicateType =
				!layerTypes.add( (Class<Layer>) l.getClass() );
			
			if (duplicateType) {
				duplicateLayerType = l;
			}
		}
		
		if (systemLayers.size() != layerTypes.size() ) {
			error("Duplicate layer type '"+ duplicateLayerType.getName() +"'. Layers must be distinct types.",
					RoboArchPackage.Literals.SYSTEM__LAYERS, LAYERS_NOT_DISTINCT_TYPES);
					
		}
		
	}
	


	@Check
	public void controlLayerPatterns(ControlLayer lyr) {
		Pattern lyrPattern = lyr.getPattern();
		
		if (lyr.getPattern() != null) {
			
			if (!(lyrPattern instanceof ReactiveSkills) && 
			    !(lyrPattern instanceof Subsumption)  ) {
				error("Pattern type cannot be used for the control layer.",
						RoboArchPackage.Literals.LAYER__PATTERN);
			}
			
		}
	}
	
	@Check
	public void executiveLayerPatterns(ExecutiveLayer lyr) {
		Pattern lyrPattern = lyr.getPattern();
		
		if (lyrPattern != null) {
			
			if ( !(lyrPattern instanceof Htn) ) {
				error("Pattern type cannot be used for the executive layer.",
							RoboArchPackage.Literals.LAYER__PATTERN);
			}
			
		}
	}
	
	@Check
	public void planningLayerPatterns(PlanningLayer lyr) {
		Pattern lyrPattern = lyr.getPattern();
		
		if (lyrPattern != null) {
			
			if ( !(lyrPattern instanceof  PlannerScheduler) && 
				!(lyrPattern instanceof  Htn)  ) {
					error("Pattern type cannot be used for the planning layer.",
							RoboArchPackage.Literals.LAYER__PATTERN);
			}
			
		}
	}
	
	

//	public static final String INVALID_NAME = "invalidName";
//
//	@Check
//	public void checkGreetingStartsWithCapital(Greeting greeting) {
//		if (!Character.isUpperCase(greeting.getName().charAt(0))) {
//			warning("Name should start with a capital",
//					RoboArchPackage.Literals.GREETING__NAME,
//					INVALID_NAME);
//		}
//	}
	
	
	
	
	/* 
	 * ReactiveSkills
	 */
	
	public static String REACTIVESKILLS_CSKILL_NOT_ASYNC =
			ISSUE_CODE_PREFIX + "NoInputCSkillMustBeAsync";
	
	@Check
	public void cskillsWithNoInputsAreAsync(CSkill cskl){
		
		if ( cskl.getInputs().isEmpty() &  !cskl.isAsync() ) {
			error("CSkill '" + cskl.getName() + "' has no inputs so must be declared asyc.",
					RoboArchPackage.Literals.SKILL__ASYNC, REACTIVESKILLS_CSKILL_NOT_ASYNC);
		}
	}
	
}
