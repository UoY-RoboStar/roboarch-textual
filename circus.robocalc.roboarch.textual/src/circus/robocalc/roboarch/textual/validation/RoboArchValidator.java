/********************************************************************************
 * Copyright (c) 2022 University of York and others
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * SPDX-License-Identifier: EPL-2.0
 *
 * Contributors:
 *   William Barnett - initial definition
 ********************************************************************************/

/*
 * generated by Xtext 2.23.0
 */
package circus.robocalc.roboarch.textual.validation;

import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.Stack;

import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EStructuralFeature;
import org.eclipse.emf.ecore.util.EcoreUtil;

import org.eclipse.xtext.validation.Check;

import circus.robocalc.roboarch.CSkill;
import circus.robocalc.roboarch.ControlLayer;
import circus.robocalc.roboarch.ExecutiveLayer;
import circus.robocalc.roboarch.Htn;
import circus.robocalc.roboarch.Layer;
import circus.robocalc.roboarch.Pattern;
import circus.robocalc.roboarch.PlannerScheduler;
import circus.robocalc.roboarch.PlanningLayer;
import circus.robocalc.roboarch.PlatformCommunicator;
import circus.robocalc.roboarch.ReactiveSkills;
import circus.robocalc.roboarch.RoboArchPackage;
import circus.robocalc.roboarch.Subsumption;
import circus.robocalc.roboarch.System;
import circus.robocalc.roboarch.util.Model;
import circus.robocalc.robochart.Connection;
import circus.robocalc.robochart.RoboChartPackage;
import circus.robocalc.robochart.RoboticPlatform;


/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
public class RoboArchValidator extends AbstractRoboArchValidator {
	
	protected static String ISSUE_CODE_PREFIX = "circus.robocalc.roboarch.";
	
	
	
	/* 
	 * Top Level
	 */
	
	//old
	public static String LAYERS_NOT_DISTINCT_TYPES =
			ISSUE_CODE_PREFIX + "LayerTypesNotDistinct";
	

	///////////////////////////////////////////////////////
	

	// S1
	public static String ROBOTIC_PLATFORM_UNUSED =
			ISSUE_CODE_PREFIX + "RoboticPlatformUnused";	
	
	// S2
	public static String LAYER_WITHOUT_IO =
			ISSUE_CODE_PREFIX + "LayerWithoutIO";		
	
	//TODO implement
	public static String LAYER_ORDER_INVALID =
			ISSUE_CODE_PREFIX + "LayerOrderInvalid";
	
	//TODO implement
	public static String CONNECTION_DIRECTION =
			ISSUE_CODE_PREFIX + "ConnectionDirection";		
	
	public static String CONNECTION_EVENT_TYPES =
			ISSUE_CODE_PREFIX + "ConnectionEventTypes";			
	
	//TODO implement
	public static String CONNECTION_ASSOCIATIONS_LAYERS =
			ISSUE_CODE_PREFIX + "ConnectionsAssociationsLayers";		
	
	//TODO implement
	public static String CONNECTION_ASSOCIATIONS_CONTROLLAYER =
			ISSUE_CODE_PREFIX + "ConnectionsAssociationsControlLayer";	
	
	//TODO implement
	public static String CONNECTIONS_PLATFORM_ASSOCIATION =
			ISSUE_CODE_PREFIX + "ConnectionsPlatformAssociation";	

	//	TODO Update according to latest well-formedness
	 

	// S1
	@Check
	public void roboticPlatformIsUsed(System sys) {
		
		// Check connections for one that exists between a layer and the platform 
		boolean layerConnectionExists; 
		
		Stack<Connection>  systemConnections = new Stack<Connection>();
		systemConnections.addAll( sys.getConnections() );
		
		layerConnectionExists = false;
		
		while (!layerConnectionExists && !systemConnections.empty() ) {
			Connection con = systemConnections.pop();
			
			if( con.getFrom() instanceof RoboticPlatform ) {
				layerConnectionExists = con.getTo() instanceof Layer;
				
			} else if ( con.getTo() instanceof RoboticPlatform ){
				layerConnectionExists = con.getFrom() instanceof Layer;
				
			} else {
				layerConnectionExists = false; // Not a connection involving the RoboticPlatform
			}
				
		}
		
		
	    // Check for a layer with an rInterface
		Stack<PlatformCommunicator> platformCommunicableLayers = new Stack<PlatformCommunicator>();
		
		platformCommunicableLayers.addAll( EcoreUtil.getObjectsByType(sys.getLayers(), RoboArchPackage.Literals.PLATFORM_COMMUNICATOR) ); 
		boolean layerWithRinterfaceExists;
		
		if ( platformCommunicableLayers.empty() ) {
			
			layerWithRinterfaceExists = false;
		}
		else {
			layerWithRinterfaceExists = false;

			while(!layerWithRinterfaceExists && !platformCommunicableLayers.empty() ) {
				PlatformCommunicator layer = platformCommunicableLayers.pop();
				
				layerWithRinterfaceExists = (layer.getRinterfaces().size() > 0); 
			}
		
		}
		
		if ( !layerConnectionExists && !layerWithRinterfaceExists) {
			error("The robotic platform must be used.", RoboArchPackage.Literals.SYSTEM__ROBOT , ROBOTIC_PLATFORM_UNUSED);
		}
		
	   
	}
	

	
	
	// S2
	@Check
	public void layerWithoutInputOrOutput(Layer lyr) { 
		
		EObject lyrParent = lyr.eContainer();
		
	    if (lyrParent instanceof System) {
	    	System sys = (System) lyrParent ;
	    	
			if ( sys.getLayers().size() > 1 ) {
				
					if( lyr.getInputs().isEmpty() && lyr.getOutputs().isEmpty() ) {
						error("Layer '" + lyr.getName() + "' has no inputs or outputs.", RoboArchPackage.Literals.LAYER__INPUTS , LAYER_WITHOUT_IO);
					}
				
			}
	    }
		
	}
	
	
	
	
	@Check
	public void layersAreDistinctTypes(System sys) {
		Set< Class<Layer> > layerTypes = new HashSet();
		List<Layer> systemLayers = sys.getLayers(); 
		Layer duplicateLayerType=null;
		
		for (Layer l: systemLayers) {
			boolean duplicateType =
				!layerTypes.add( (Class<Layer>) l.getClass() );
			
			if (duplicateType) {
				duplicateLayerType = l;
			}
		}
		
		if (systemLayers.size() != layerTypes.size() ) {
			error("Duplicate layer type '"+ duplicateLayerType.getName() +"'. Layers must be distinct types.",
					RoboArchPackage.Literals.SYSTEM__LAYERS, LAYERS_NOT_DISTINCT_TYPES);
					
		}
		
	}
	


	@Check
	public void controlLayerPatterns(ControlLayer lyr) {
		Pattern lyrPattern = lyr.getPattern();
		
		if (lyr.getPattern() != null) {
			
			if (!(lyrPattern instanceof ReactiveSkills) && 
			    !(lyrPattern instanceof Subsumption)  ) {
				error("Pattern type cannot be used for the control layer.",
						RoboArchPackage.Literals.LAYER__PATTERN);
			}
			
		}
	}
	
	@Check
	public void executiveLayerPatterns(ExecutiveLayer lyr) {
		Pattern lyrPattern = lyr.getPattern();
		
		if (lyrPattern != null) {
			
			if ( !(lyrPattern instanceof Htn) ) {
				error("Pattern type cannot be used for the executive layer.",
							RoboArchPackage.Literals.LAYER__PATTERN);
			}
			
		}
	}
	
	@Check
	public void planningLayerPatterns(PlanningLayer lyr) {
		Pattern lyrPattern = lyr.getPattern();
		
		if (lyrPattern != null) {
			
			if ( !(lyrPattern instanceof  PlannerScheduler) && 
				!(lyrPattern instanceof  Htn)  ) {
					error("Pattern type cannot be used for the planning layer.",
							RoboArchPackage.Literals.LAYER__PATTERN);
			}
			
		}
	}
	
	
	@Check
	public void connectionFromIsAnOutput(Connection con ) {
		
		
		if ( con.getFrom() instanceof Layer ) {
			
			Layer lyr = (Layer)  con.getFrom(); 
			
			//Check for inputs that are invalid 
			if ( Model.isEventLayerInput( lyr, con.getEfrom() ) )  {
			
				error("The source of a connection must be an output.", RoboChartPackage.Literals.CONNECTION__EFROM , CONNECTION_DIRECTION);
			}
			

		}
		
	} 
	
	@Check
	public void connectionToIsAnInput(Connection con ) {

		if ( con.getTo() instanceof Layer ) {
			
			Layer lyr = (Layer)  con.getTo(); 
			
			//Check for outputs that are invalid 
			if ( Model.isEventLayerOutput( lyr, con.getEto() ) )  {
				
				error("The destination of a connection must be an input.", RoboChartPackage.Literals.CONNECTION__ETO , CONNECTION_DIRECTION);
			}
			
		}
		
	} 
//	public static final String INVALID_NAME = "invalidName";
//
//	@Check
//	public void checkGreetingStartsWithCapital(Greeting greeting) {
//		if (!Character.isUpperCase(greeting.getName().charAt(0))) {
//			warning("Name should start with a capital",
//					RoboArchPackage.Literals.GREETING__NAME,
//					INVALID_NAME);
//		}
//	}
	
	
	
	
	/* 
	 * ReactiveSkills
	 */
	
	public static String REACTIVESKILLS_CSKILL_NOT_ASYNC =
			ISSUE_CODE_PREFIX + "NoInputCSkillMustBeAsync";
	
	@Check
	public void cskillsWithNoInputsAreAsync(CSkill cskl){
		
		if ( cskl.getInputs().isEmpty() &  !cskl.isAsync() ) {
			error("CSkill '" + cskl.getName() + "' has no inputs so must be declared asyc.",
					RoboArchPackage.Literals.SKILL__ASYNC, REACTIVESKILLS_CSKILL_NOT_ASYNC);
		}
	}
	
}
