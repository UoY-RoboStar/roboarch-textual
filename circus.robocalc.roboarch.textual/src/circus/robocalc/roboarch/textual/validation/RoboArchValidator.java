/********************************************************************************
 * Copyright (c) 2022 University of York and others
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * SPDX-License-Identifier: EPL-2.0
 *
 * Contributors:
 *   William Barnett - initial definition
 ********************************************************************************/

/*
 * generated by Xtext 2.23.0
 */
package circus.robocalc.roboarch.textual.validation;

import java.util.HashSet;
import java.util.List;
import java.util.Set;

import org.eclipse.xtext.validation.Check;

import circus.robocalc.roboarch.CSkill;
import circus.robocalc.roboarch.ControlLayer;
import circus.robocalc.roboarch.ExecutiveLayer;
import circus.robocalc.roboarch.Htn;
import circus.robocalc.roboarch.Layer;
import circus.robocalc.roboarch.Pattern;
import circus.robocalc.roboarch.PlannerScheduler;
import circus.robocalc.roboarch.PlanningLayer;
import circus.robocalc.roboarch.ReactiveSkills;
import circus.robocalc.roboarch.RoboArchPackage;
import circus.robocalc.roboarch.Subsumption;
import circus.robocalc.roboarch.System;
import circus.robocalc.roboarch.util.Model;
import circus.robocalc.robochart.Connection;
import circus.robocalc.robochart.RoboChartPackage;


/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
public class RoboArchValidator extends AbstractRoboArchValidator {
	
	protected static String ISSUE_CODE_PREFIX = "circus.robocalc.roboarch.";
	
	
	
	/* 
	 * Top Level
	 */
	
	//old
	public static String LAYERS_NOT_DISTINCT_TYPES =
			ISSUE_CODE_PREFIX + "LayerTypesNotDistinct";
	
	//old
	public static String LAYER_WITHOUT_PATTERN =
			ISSUE_CODE_PREFIX + "LayerWithoutPattern";
	
	///////////////////////////////////////////////////////
	
	//TODO implement
	public static String ROBOTIC_PLATFORM_UNUSED =
			ISSUE_CODE_PREFIX + "RoboticPlatformUnused";	
	
	//TODO implement
	public static String LAYER_WITHOUT_IO =
			ISSUE_CODE_PREFIX + "LayerWithoutIO";		
	
	//TODO implement
	public static String LAYER_ORDER_INVALID =
			ISSUE_CODE_PREFIX + "LayerOrderInvalid";
	
	//TODO implement
	public static String CONNECTION_DIRECTION =
			ISSUE_CODE_PREFIX + "ConnectionDirection";		
	
	public static String CONNECTION_EVENT_TYPES =
			ISSUE_CODE_PREFIX + "ConnectionEventTypes";			
	
	//TODO implement
	public static String CONNECTION_ASSOCIATIONS_LAYERS =
			ISSUE_CODE_PREFIX + "ConnectionsAssociationsLayers";		
	
	//TODO implement
	public static String CONNECTION_ASSOCIATIONS_CONTROLLAYER =
			ISSUE_CODE_PREFIX + "ConnectionsAssociationsControlLayer";	
	
	//TODO implement
	public static String CONNECTIONS_PLATFORM_ASSOCIATION =
			ISSUE_CODE_PREFIX + "ConnectionsPlatformAssociation";	

	//	TODO Update according to latest well-formedness
	 

	@Check
	public void layersAreDistinctTypes(System sys) {
		Set< Class<Layer> > layerTypes = new HashSet();
		List<Layer> systemLayers = sys.getLayers(); 
		Layer duplicateLayerType=null;
		
		for (Layer l: systemLayers) {
			boolean duplicateType =
				!layerTypes.add( (Class<Layer>) l.getClass() );
			
			if (duplicateType) {
				duplicateLayerType = l;
			}
		}
		
		if (systemLayers.size() != layerTypes.size() ) {
			error("Duplicate layer type '"+ duplicateLayerType.getName() +"'. Layers must be distinct types.",
					RoboArchPackage.Literals.SYSTEM__LAYERS, LAYERS_NOT_DISTINCT_TYPES);
					
		}
		
	}
	


	@Check
	public void controlLayerPatterns(ControlLayer lyr) {
		Pattern lyrPattern = lyr.getPattern();
		
		if (lyr.getPattern() != null) {
			
			if (!(lyrPattern instanceof ReactiveSkills) && 
			    !(lyrPattern instanceof Subsumption)  ) {
				error("Pattern type cannot be used for the control layer.",
						RoboArchPackage.Literals.LAYER__PATTERN);
			}
			
		}
	}
	
	@Check
	public void executiveLayerPatterns(ExecutiveLayer lyr) {
		Pattern lyrPattern = lyr.getPattern();
		
		if (lyrPattern != null) {
			
			if ( !(lyrPattern instanceof Htn) ) {
				error("Pattern type cannot be used for the executive layer.",
							RoboArchPackage.Literals.LAYER__PATTERN);
			}
			
		}
	}
	
	@Check
	public void planningLayerPatterns(PlanningLayer lyr) {
		Pattern lyrPattern = lyr.getPattern();
		
		if (lyrPattern != null) {
			
			if ( !(lyrPattern instanceof  PlannerScheduler) && 
				!(lyrPattern instanceof  Htn)  ) {
					error("Pattern type cannot be used for the planning layer.",
							RoboArchPackage.Literals.LAYER__PATTERN);
			}
			
		}
	}
	
	
	@Check
	public void connectionFromIsAnOutput(Connection con ) {
		
		
		if ( con.getFrom() instanceof Layer ) {
			
			Layer lyr = (Layer)  con.getFrom(); 
			
			//Check for inputs that are invalid 
			if ( Model.isEventLayerInput( lyr, con.getEfrom() ) )  {
			
				error("The source of a connection must be an output.", RoboChartPackage.Literals.CONNECTION__EFROM , CONNECTION_DIRECTION);
			}
			

		}
		
	} 
	
	@Check
	public void connectionToIsAnInput(Connection con ) {

		if ( con.getTo() instanceof Layer ) {
			
			Layer lyr = (Layer)  con.getTo(); 
			
			//Check for outputs that are invalid 
			if ( Model.isEventLayerOutput( lyr, con.getEto() ) )  {
				
				error("The destination of a connection must be an input.", RoboChartPackage.Literals.CONNECTION__ETO , CONNECTION_DIRECTION);
			}
			
		}
		
	} 
//	public static final String INVALID_NAME = "invalidName";
//
//	@Check
//	public void checkGreetingStartsWithCapital(Greeting greeting) {
//		if (!Character.isUpperCase(greeting.getName().charAt(0))) {
//			warning("Name should start with a capital",
//					RoboArchPackage.Literals.GREETING__NAME,
//					INVALID_NAME);
//		}
//	}
	
	
	
	
	/* 
	 * ReactiveSkills
	 */
	
	public static String REACTIVESKILLS_CSKILL_NOT_ASYNC =
			ISSUE_CODE_PREFIX + "NoInputCSkillMustBeAsync";
	
	@Check
	public void cskillsWithNoInputsAreAsync(CSkill cskl){
		
		if ( cskl.getInputs().isEmpty() &  !cskl.isAsync() ) {
			error("CSkill '" + cskl.getName() + "' has no inputs so must be declared asyc.",
					RoboArchPackage.Literals.SKILL__ASYNC, REACTIVESKILLS_CSKILL_NOT_ASYNC);
		}
	}
	
}
